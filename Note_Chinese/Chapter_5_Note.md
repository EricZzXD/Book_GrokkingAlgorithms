# 算法图解笔记 -> 第五章: 散列表

## 本章内容
   - 学习散列表 -- 最有用的基本数据结构之一。散列表用途广泛,本章将解释其常见的用途
   - 学习山列表的内部机制: 实现，冲突和散列函数。 

## 5.1 散列函数 -> P60
   - 散列函数——> 无论你给他什么数据，他都还给你一个数据。 
   
   - 散列函数必须满足一些要求: 
       - 它们必须是一致的。 例如：输入Apple是得到的是4， 那么每次输入Apple的结果必须为4.
       - 它应将不同的输入映射到不同的数字。例如：如果一个散列函数不管输入是什么都返回1.
   
   - 步骤：
       - 创建一个空数组：
           - 把名字输入给散列函数
           - 加入输出为3，那么在空数组的index 3放入物品的价格
           - 以此类推，填满空数组，那么每当输入物品的名字，可轻易找到物品价格

   - 散列函数准确的指出价格的存储位置，原因：
       - 散列函数总是把相同的输入映射的相同的索引(index), 并在相同的索引内储存价格
       - 散列函数将不同的输入映射到不同的索引。 例如： 苹果映射索引3， 牛奶映射索引1
       - 散列函数直到数组的大小，只返回有效索引。如果数组大小为5，那么散列函数不会返回索引100. 
      
   - 数组，链表和散列表的不同
       - 数组和链表都被直接映射到内存
       - 散列表使用散列函数来确定元素的存储位置
      
   - 练习 -> P62
        对于同样的输入，散列表必须返回同样的输出，这一点很重要。如果不是这样的，就无法找到你在散列表中添加的元素！
        请问下面那些函数是一致的？
        - 5.1 f(x) = 1 <--- 无论输入是什么，都返回1
            - 一致，对于同样的输入，输出都是1
        - 5.2 f(x) = rand() <--- 每次都返回一个随机数
            - 不一致，同样的输入，输出是不同的随机数 
        - 5.3 f(x) = next_empty_slot <---返回散列表下一个空的索引
            - 不一致，对于相同的输入，散列表返回下一个空位置的索引，而下一个空位置的索引随时可能变化。
        - 5.4 f(x) = len(x) <--- 将字符串的长度作为索引
            - 一致，对于相同的输入，散列表返回的始终是该输入字符串的长度。 
   
   
## 5.2.1 应用案例: 散列表用于查找-> P63
   -  手机电话簿 例子：
       - Jenny --- 0401 123 456
       - Eric  --- 0401 456 789
       - Tim   --- 0401 741 852
   
   - 电话簿的功能：
       - 添加联系人及其电话号码。
       - 通过输入联系人来获悉其电话号码。
       
   - 创建映射
       ```
            # Python 提供了一个创建散列表的快捷方式 ----- 使用一对大括号
            >>> phone_book = dict() 
                OR
            >>> phone_book = {}
       ```
      
   - 添加一些联系人的电话号码
       ```
            >>> phone_book["Jenny"] = 0401 123 456
            >>> phone_book["Eric"] = 0401 456 789
            >>> phone_book["Tim"] = 0401 741 852
       ``` 
       
   - 寻找联系人的电话号码
        ```
            >>> print phone_book["Jenny"]
                0401 123 456
        ```
      
## 5.2.2 应用案例: 防止重复-> P64
   - 投票站 - 要求：
       - 一人只能投一票
       - 投票名单非常的长
       
   - 创建一个散列表并检查是否投过票
       ```
            # 创建散列表
            >>> voted = {}
     
            # 检查改投票人是否已投票
            >>> value = voted.get("Tom")
            
        ```
   
   - 具体代码: 
       ```
            voted = {}
     
            def check_voter(name):
                if value = voted.get(name):
                    print "Kick them out!"
                else:
                    voted[name] = True
                    print "Let them vote!"
        ``` 
   
   
## 5.2.3 应用案例: 将散列表作为缓存-> P66
   - 缓存的优点：
       - 用户能更快的看到网页 ---- 已经搜索过的资料或内容被保存了，无需再重复下载
       - 服务器的压力变小

   - 当访问网页的时候(具体链接)， 浏览器先检查散列表中是否储存该页面(该网页可能存储缓存到浏览器中)
       - 有 -> 发送缓存数据
       - 没有 -> 让服务器做处理
       
   - 具体代码
       ```
           cache = {}
            
           def get_page(url):
               if cache.get(url):
                   return cache[url]   <---- 返回缓存数据
               else:
                   data = get_data_from_server(url)
                   cache[url] = data   <---- 先将数据保持到缓存
                   return data
       ```
   
## 5.2.4 小结-> P68 
   - 5.2.4 小结
       - 散列表适用于：
           - 模拟映射关系
           - 防止重复
           - 缓存/记住数据，以免服务器再通过处理来生成他们
           
       - 
   
   
## 5.3 冲突 -> P69
   - 事实：
       - 散列函数总是将不同的键映射到数组的不同位置(实际上是几乎不可能实现的)
       
   - 冲突: 
       - 当输入到散列函数后输出的结果相同，这种情况被称为冲突(Collision)
       
   - 解决方法1 (散列表加链表)：
       - 结果：
           - 当两个键映射到同一个位置，就再这个位置储存一个链表
           - 当链表很短的时候，速度会受到影响
           - 但当链表很长的时候，速度会收到很大的影响

       - 经验：
           - 散列函数很重要。 (最理想的情况是，散列函数将键均匀的映射到散列表的不同位置)
           - 如果使用散列函数很好，这些链表就不会很长。(散列表储存的链表很长，散列表的速度会急剧下降)
           

## 5.4 性能 -> P71
   
   - 散列表各种朝朝的时间为 O(1)。 
   - O(1)被成为常量时间。 
   - 常量时间 -> 并不意味马上，而是说不管散列表多大，所需的时间相同。
   
   - note：
       - 简单查找 -> 线性时间
       - 二分法查找 -> 对数时间
       - 散列表查找 -> 常量时间
       
       
   - 散列表和数组和链表对比
   
        |      | 散列表（平均情况）  |  散列表（最差情况）  | 数组  |  链表  | 
        |------|------------------|------------------|-------|-------|
        | 查找  |         O(1)     |       O(n)       | O(1)  | O(n)  |
        | 插入  |      O(1)        |       O(n)       | O(n)  | O(1)  |
        |  删除 |      O(1)        |       O(n)       | O(n)  | O(1)  |
        
   - 散列表避免最糟糕情况 （避免冲突）：
       - 较低的填装因子
       - 良好的散列函数
       


## 5.4.1 填装因子 -> P72
   - 散列表的填装因子计算
       - (散列表包含的元素数)/(位置总是)
       
   - 填装因子计算例子:
       - 例子 1： 
           - 散列表已用位置数为：2
           - 散列表的总位置数为：5       
           - 填装因子： 2/5 = 0.4

       - 例子 2:
           - 散列表已用位置数为：100
           - 散列表的总位置数为：100     
           - 填装因子： 100/100 = 1
           
       - 例子 3:
           - 散列表已用位置数为：100
           - 散列表的总位置数为：50     
           - 填装因子： 100/50 = 2
                  
   - 当填装因子增大，则需要在散列表中添加位置，这被成为<b>调整长度（resizing）</b>
   - 当填装因子低，发生冲突的可能性变小，散列表性能越好
       - 当填装因子>0.7,则调整散列表的长度
   - 

## 5.4.2 良好的散列函数 -> P74
   - 良好的散列函数
       - 数组中的值平均分布
       
   - 糟糕的散列函数
       - 导致大量的冲突，数值扎堆
       
   - 练习 -> P74
       - 散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。
       - 假设你有四个处理字符串的散列函数
           - A. 不管输入是什么，都返回1
           - B. 将字符串的长度用作索引。
           - C. 将字符串的第一个字符用作索引。即将所有以a打头的字符串都映射到散列表的同一个位置，以此类推
           - D. 将每个字符都映射到一个素数：a = 2，b = 3，c = 5，d = 7，e = 11，等等。对于给定的字符串，这个散列函数将其中每个字符对应的素数相加，再计算结果除以散列表长度的余数。例如，如果散列表的长度为10，字符串为bag，则索引为(3 + 2 + 17) % 10 = 22 % 10 = 2。

       - 在下面的每个示例中，上述哪个散列函数可实现均匀分布？假设散列表的长度为10。
       - 5.5 将姓名和电话号码分别作为键和值的电话簿，其中联系人姓名为Esther、Ben、Bob和Dan。
           - D
       - 5.6 电池尺寸到功率的映射，其中电池尺寸为A、AA、AAA和AAAA
           - B & D
       - 5.7 书名作者的映射，其中书名分别为Maus、Fun Home和Watchmen。
           - B & C & D 
   
   
## 5.4 总结 -> P75
   - 散列表是一种功能强大的数据结果，操作速度快，还能一不同的方式建立数据模型
       - 可以结合散列表和数组来建立散列表
       - 冲突很糟糕，应使用最大限度减少冲突的散列函数
       - 散列表的查找，插入和删除速度都非常快
       - 散列表适合用于模拟映射关系
       - 一旦填装因子超过0.7，就应该调整散列表长度
       - 散列表可应用于缓存数据 (例如，在Web服务器上)
       - 散列表非常适合用于防止重复
