# 算法图解笔记 -> 第一章: 算法介绍

## 1.1 引言
   - 二分法查找  -> P2
        - 它是一个查找算法在一个已排列好的数组中选择目标的位置
        - **最差情况的大O运行时间**: O(log n)
        - 运行原理 (例子)
            - array = [1,2,3,4,5,6,7,8,9], target = 8
            - 选择中间的index的数值 -> (0+(9-1)) = 4 -> array[4] = 5
            - array[4] < 8, low_index = 4+1 = 5 
            - new_mid_index = (5+(9-1))= 7 -> array[7] = 8 == target 
            - 返回 mid_index
       
   - 练习 -> P8
        - **1.1**: 假设有一个包含128个名字的有序列表，你要使用二分查找在其中查找一个名字，请问最多需要几步才能找到？
            - 最多需要7步 (128 -> 64 -> 32 -> 16 -> 8 -> 4 -> 2 -> 1)

        - **1.2**: 上面列表的长度翻倍后，最多需要几步？
            - 八步 因为翻倍只增加一个步骤
            

## 1.2 运行时间 -> 没笔记 -> P8

## 1.3 大O表示法 -> P8
   - 大O表示法指出最赵高情况下的运行时间
   - 一些常见的大O 运行时间  -> P12 
        - O(log n)，也叫对数时间，这样的算法包括**二分查找**。
        - O(n)，也叫线性时间，这样的算法包括**简单查找**。
        - O(n * log n)，这样的算法包括第4章将介绍的**快速排序**——一种速度较快的排序算法。
        - O(n2)，这样的算法包括第2章将介绍的**选择排序**——一种速度较慢的排序算法。
        - O(n!)，这样的算法包括接下来将介绍的**旅行商问题**的解决方案——一种非常慢的算法。
        
   - 练习 -> P13
       - 1.3 在电话簿中根据名字查找电话号码。
           - O(log n) -> 由于电话簿是根据名字排列的, 通过对比名字搜索
           
       - 1.4 在电话簿中根据电话号码找人。（提示：你必须查找整个电话簿。）
           -  O(n) -> 需要一个一的的检查 (电话号码没有排序)
           
       - 1.5 阅读电话簿中每个人的电话号码。
           - O(n) -> 阅读电话簿的每一个电话, 需要经历所以电话
           
       - 1.6 阅读电话簿中姓名以A打头的人的电话号码。这个问题比较棘手，它涉及第4章的概念。答案可能让你感到惊讶！
           - O(n) -> 原因暂时不明
           
           
   - 旅行商问题 -> P13
       - 大O运行时间: O(n!)
       - 问题: 有一位旅行商, 他需要前往5个城市, 同时要确保旅程最短。为此，可考虑前往这些城市的各种可能顺序。
           - 五个城市有120种不同的排列方式 -> 5*4*3*2*1 = 120
           

## 总结
   - 二分查找的速度比简单查找快得多。
   - O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
   - 算法运行时间并不以秒为单位。
   - 算法运行时间是从其增速的角度度量的。
   - 算法运行时间用大O表示法表示。