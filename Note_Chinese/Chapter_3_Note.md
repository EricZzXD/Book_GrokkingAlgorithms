# 算法图解笔记 -> 第三章: 递归

## 3.1 递归 -> P29
   - 递归的用法
       - 函数调用自己.... 很难解释（上网找资料）
   - 递归的特点
       - 递归只是让解决方案更清晰，没有性能上的优势。 
       - 如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解，如何选择要看什么对你说更重要。
   
   
## 3.2 极限条件和递归条件 -> P32   
   - 问题
        - 由于递归函数调用自己，因此很容易出错，进而导致无线循环。
   - 解决方法
        - 编写函数时，必须写好停止条件
            - 基线条件： 函数调用自己
            - 递归条件：函数不在调用自己
        ```
            def countdown(i):
                print i
                if i<=0:             -----基线条件
                    return i
                else：
                    countdown(i-1)   -----递归条件
        ```
     
     
## 3.3 栈（zhan） -> P33
   - 特点：
       - 原则：先进后出
       - 栈的操作只有两种，压入（push）和弹出（pop)，
           - 压入 -- 在最上面添加数据或代办事项
           - 弹出 -- 删除并读取最上面的代办事项
          
   - 例子：
       - 堆箱子 -- 把箱子堆在一起，拿箱子的时候必须先把外面的箱子拿出来才可以把里面的现在拿出去。 
      


## 3.3.1 调用栈（zhan） -> P34
   - 调用栈例子：         
    
        ```
             def greet(name):
                  print "Hello, " + name + "!"
                  greet2(name)
                  print "Getting ready to say goodbye..."
                  bye("greet1")
                
                def bye(number):
                  print "Bye " + number
                
                def greet2(name):
                  print "How are you " + name + "?"
                  bye("greet2")
                
                greet("Eric")
                
        ```
    
        结果：
        
            Hello, Eric!                    ---- From greet
            How are you Eric?               ---- From greet2
            Bye greet2                      ---- From greet2's bye()
            Getting ready to say goodbye... ---- From greet
            Bye greet 1                     ---- From greet
       
    
    
   - 练习 -> P36
        - 3.1 根据下面的调用栈，你获得那些信息？ （P36）
            1. 调用了函数greet， 并将参数name的值指定为maggle；
            2. 函数greet调用了函数greet2， 并将参数name的值指定为maggle；
            3. 此时函数greet处于未完成状态；
            4. 当前调用的函数为greet2；
            5. 这函数执行完毕后，函数greet将接着执行
      
 
## 3.3.2 递归调用栈（zhan） -> P36

   - 递归调用栈例子
        - Factorial的调用栈， factorial（5）写作5！= 5*4*3*2*1 同理 factorial（3）== 3！== 3*2*1
        ```
            def fact(x)
                if x == 1:
                    return 1
                else:
                    return x* fact(x-1)
        ```
    
        - fact(3) 解释：
            - x = 3 != 1 调用 x * fact(x-1) == 3 * fact(2)  ----- fact(3) 未结束，因为调用了fact(2)
            - x = 2 != 1 调用 x * fact(x-1) == 2 * fact(1)  ----- fact(2) 未结束，因为调用了fact(1)
            - x = 1 == 1 返回 1                             ----- fact(1) 已结束，返回上一步fact(2)
            - 在fact(2)， 从fact（1） 返回1, 计算结果为 2*1 = 2， fact（2）运行结束。 结果返回fact（3）
            - 在fact（3）， 最终结果为 3*2 = 6 

   - 栈的特点
        - 栈很方便，但是要付出代价：存储详尽的信息可能占用大量的内存（在fact(3)中，内存并不是储存计算结果，而是保存每一步计算的x并保持在内存中）。
        - 每个函数调用都要占用一定的内存，如果栈很高，这意味着计算机需要存储大量的函数调用信息。 
        - 解决方法
            - 重新编写代码，转而使用循环。
            - 使用尾递归。 这是一个高级递归主题，不在本书条论的范围（并不算所有语言都支持尾递归）。 
            
            
  - 练习 -> P40
    - 3.2 假设你编写了一个递归函数，但不小心导致他没完没了的运行。 正如你看到的，对于每次函数调用，计算机都将为其在栈中分配内存。机柜函数没完没了的运行时，将给栈带来什么影响？
        - 栈将不断的扩大。 应为每个程序可是哟ing的调用栈空间有限，程序用完这些空间后，将因栈的溢出二终止。
      
## 总结
   - 3.4 小结
        - 递归指的是调用自己的函数
        - 每个递归的函数都用两个条件：基线条件和递归条件
        - 栈有两个操作：压入和弹出
        - 所有函数调用都进入调用栈
        - 调用栈可能很长，这将占用大量的内存
